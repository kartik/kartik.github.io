<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comments</title>
    <style>
        /* Basic Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 600px;
            margin: 20px auto;
            padding: 10px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #FF4500; /* Reddit's orange color */
            font-weight: 300;
        }

        /* Control Panel Styles */
        .control-panel {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .subreddit-input {
            display: flex;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 20px;
            padding: 5px 10px;
            background-color: #fff;
        }

        .subreddit-input input {
            border: none;
            outline: none;
            padding: 5px;
            font-size: 1em;
            border-radius: 20px;
            width: 177px;
        }

        .subreddit-input button {
            background: none;
            border: none;
            cursor: pointer;
            margin-left: 5px;
            font-size: 1.2em;
            color: #FF4500;
        }

        .time-range {
            display: flex;
            gap: 10px;
        }

        .chip {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background-color: #e0e0e0;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            font-size: 0.9em;
        }

        .chip.active, .chip:hover {
            background-color: #FF4500;
            color: #fff;
        }

        /* Card Styles */
        #postsContainer {
            margin-top: 0px;
        }
        .card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
            transition: transform 0.2s;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-header h2 {
            font-size: 0.9em;
            flex: 1;
            margin-right: 10px;
            font-weight: 400;
            color: #22aaff;
        }

        .card-header .subreddit {
            font-size: 0.9em;
            color: #555;
            margin-right: 10px;
        }

        .card-header .upvotes {
            font-size: 0.9em;
            display: flex;
            align-items: center;
        }

        .card-header .upvotes::before {
            content: '▲';
            margin-right: 5px;
            font-size: 0.8em;
        }

        .card-selftext {
            padding: 10px 20px;
            font-size: 0.8em;
        }

        /* Single Image Styling */
        .card-image img {
            width: 100%;
            height: auto;
            display: block;
        }

        /* Video Styling */
        .card-video video {
            width: 100%;
            height: auto;
            display: block;
            cursor: pointer;
        }

        /* Gallery Styles */
        .card-gallery {
            position: relative;
            width: 100%;
            overflow: hidden;
            /* Remove fixed height to allow dynamic resizing */
        }

        .gallery-slides {
            display: flex;
            transition: transform 0.3s ease-in-out;
            /* Ensure slides take only necessary height */
            height: auto;
        }

        .gallery-slides img {
            width: 100%;
            flex-shrink: 0;
            height: auto; /* Preserve aspect ratio */
            object-fit: contain; /* Ensure images fit without distortion */
        }

        .gallery-nav {
            position: absolute;
            top: 50%;
            width: 100%;
            display: flex;
            justify-content: space-between;
            transform: translateY(-50%);
            pointer-events: none;
        }

        .gallery-nav button {
            background-color: rgba(0,0,0,0.5);
            border: none;
            color: #fff;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 50%;
            pointer-events: all;
            transition: background-color 0.3s;
        }

        .gallery-nav button:hover {
            background-color: rgba(0,0,0,0.7);
        }

        /* Carousel Indicators */
        .gallery-indicators {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .gallery-indicators span {
            width: 10px;
            height: 10px;
            background-color: rgba(80,80,80,0.6);
            border: 2px solid rgba(255,255,255,0.9);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        .gallery-indicators span.active {
            background-color: #FF4500;
            border-color: #fff;
        }

        /* Focused gallery for keyboard nav */
        .card-gallery.gallery-focused {
            outline: 2px solid #FF4500;
            outline-offset: -2px;
        }

        /* Card Content */
        .card-content {
            padding: 15px 20px;
            display: none;
            border-top: 1px solid #eee;
        }

        .comment {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .comment:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .comment-body {
            margin-bottom: 5px;
            font-size: 0.95em;
        }

        .comment-upvotes {
            font-size: 0.9em;
            display: flex;
            align-items: center;
        }

        .comment-upvotes::before {
            content: '▲';
            margin-right: 5px;
            font-size: 0.8em;
        }

        /* Markdown Styles */
        .card-selftext a, .comment-body a {
            color: #0066cc;
            text-decoration: none;
            word-break: break-word;
        }

        .card-selftext a:hover, .comment-body a:hover {
            text-decoration: underline;
        }

        .card-selftext blockquote, .comment-body blockquote {
            border-left: 3px solid #FF4500;
            padding-left: 10px;
            margin: 8px 0;
            color: #555;
            font-style: italic;
        }

        .card-selftext code, .comment-body code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .card-selftext img, .comment-body img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin: 8px 0;
        }

        /* Loading Spinner */
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            color: #555;
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #FF4500;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 0.5s linear infinite;
            margin: 0 auto 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .card-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .card-header h2 {
                margin-bottom: 10px;
            }

            .card-header .subreddit,
            .card-header .upvotes {
                margin-right: 0;
            }

            .control-panel {
                flex-direction: column;
                align-items: center;
            }

            .subreddit-input input {
                width: 150px;
            }

            .gallery-nav button {
                padding: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="subreddit-input">
                <input type="text" id="subredditInput" placeholder="Sub" />
                <button id="addSubreddit" title="Add Subreddit">→</button>
            </div>
            <div class="time-range">
                <button class="chip active" data-time="day">Day</button>
                <button class="chip" data-time="week">Week</button>
                <button class="chip" data-time="month">Month</button>
                <button class="chip" data-time="year">Year</button>
                <button class="chip" data-time="all">All</button>
            </div>
        </div>
        <div id="postsContainer">
            <!-- Post cards will be inserted here -->
        </div>
        <div class="loading" id="loading">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- jQuery CDN -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        // Configuration Constants
        let SUBREDDIT = 'singularity'; // Default subreddit
        let TIMEFRAME = 'day';            // Default timeframe
        const POST_LIMIT = 20;            // Number of posts to fetch per request
        const MIN_UPVOTES = 10;           // Minimum upvotes for comments
        const TOTAL_POSTS = 100;          // Target number of posts to fetch in total
        let after = null;                 // Pagination marker for Reddit API
        let fetchedPosts = 0;             // Counter for fetched posts
        let lock = false;                 // Lock to prevent multiple concurrent fetches
        let loadedIDArray = [];           // Array to store loaded post IDs

        // Regular Expression to check for image URLs
        const imageRegEx = /.*\.(jpg|jpeg|png|gif)$/i;

        // Initialize on document ready
        $(document).ready(function() {
            fetchTopPosts();

            // Infinite Scroll
            $(window).on('scroll', function() {
                if ($(window).scrollTop() + $(window).height() >= $(document).height() - 500) {
                    fetchTopPosts();
                }
            });

            // Time Range Selection
            $('.chip').on('click', function() {
                if ($(this).hasClass('active')) return; // Do nothing if already active
                $('.chip').removeClass('active');
                $(this).addClass('active');
                TIMEFRAME = $(this).data('time');
                resetPosts();
                fetchTopPosts();
            });

            // Add Subreddit
            $('#addSubreddit').on('click', function() {
                const subredditInput = $('#subredditInput').val().trim();
                if (subredditInput !== '') {
                    SUBREDDIT = subredditInput;
                    $('#subredditInput').val('');
                    resetPosts();
                    fetchTopPosts();
                }
            });

            // Allow pressing Enter to add subreddit
            $('#subredditInput').on('keypress', function(e) {
                if (e.which === 13) { // Enter key
                    $('#addSubreddit').click();
                }
            });
        });

        function resetPosts() {
            after = null;
            fetchedPosts = 0;
            loadedIDArray = [];
            $('#postsContainer').empty();
        }

        function fetchTopPosts(retryCount = 0) {
            const MAX_RETRIES = 3;
            const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff

            if (fetchedPosts >= TOTAL_POSTS || lock) return;

            lock = true;
            $('#loading').show().find('.spinner').show();
            $('#loading').find('p').remove(); // Clear any error messages

            let url = `https://www.reddit.com/r/${SUBREDDIT}/top/.json?limit=${POST_LIMIT}&t=${TIMEFRAME}&raw_json=1`;
            if (after) {
                url += `&after=${after}`;
            }

            $.ajax({
                url: url,
                method: 'GET',
                dataType: 'json',
                timeout: 15000, // 15 second timeout
                success: function(data) {
                    if (!data || !data.data || !data.data.children) {
                        handleFetchError('Invalid response from Reddit', retryCount, MAX_RETRIES, RETRY_DELAYS);
                        return;
                    }

                    const posts = data.data.children;
                    after = data.data.after;

                    posts.forEach(post => {
                        if (fetchedPosts >= TOTAL_POSTS) return;

                        const postData = post.data;

                        // Skip NSFW posts
                        if (postData.over_18) return;

                        // Avoid duplicates
                        if (loadedIDArray.includes(postData.id)) return;

                        const postId = postData.id;
                        const postTitle = postData.title;
                        const postSelfText = postData.selftext;
                        const subreddit = postData.subreddit;
                        const upvotes = postData.ups;
                        const postURL = postData.url;
                        const isGallery = postData.is_gallery || false;
                        const mediaMetadata = postData.media_metadata || {};
                        const galleryData = postData.gallery_data || {};

                        // Check if the post has an image
                        const hasImage = imageRegEx.test(postURL);
                        const imageUrl = hasImage ? postURL : null;

                        // Extract gallery images if applicable
                        let galleryImages = [];
                        if (isGallery && galleryData.items) {
                            galleryData.items.forEach(item => {
                                const mediaId = item.media_id;
                                if (mediaMetadata[mediaId] && mediaMetadata[mediaId].s && mediaMetadata[mediaId].s.u) {
                                    // Replace &amp; with & in URLs
                                    const imageLink = mediaMetadata[mediaId].s.u.replace(/&amp;/g, '&');
                                    galleryImages.push(imageLink);
                                }
                            });
                        }

                        // Check if the post is a video
                        const isVideo = postData.is_video;
                        const videoUrl = isVideo && postData.media && postData.media.reddit_video && postData.media.reddit_video.fallback_url ? postData.media.reddit_video.fallback_url : null;

                        createPostCard(postId, postTitle, postSelfText, subreddit, upvotes, imageUrl, galleryImages, isVideo, videoUrl);
                        fetchedPosts++;
                        loadedIDArray.push(postId);
                    });

                    // Hide loading spinner if no more posts
                    if (!after || fetchedPosts >= TOTAL_POSTS) {
                        $('#loading').hide();
                    }

                    lock = false;
                },
                error: function(xhr, status, err) {
                    console.error('Error fetching posts:', status, err);
                    handleFetchError(status === 'timeout' ? 'Request timed out' : err, retryCount, MAX_RETRIES, RETRY_DELAYS);
                }
            });
        }

        function handleFetchError(errorMsg, retryCount, maxRetries, retryDelays) {
            if (retryCount < maxRetries) {
                const delay = retryDelays[retryCount];
                console.log(`Retrying in ${delay}ms... (attempt ${retryCount + 2}/${maxRetries + 1})`);
                $('#loading').find('.spinner').hide();
                $('#loading').append(`<p style="font-size: 0.9em;">Retrying... (${retryCount + 2}/${maxRetries + 1})</p>`);
                lock = false;
                setTimeout(() => {
                    fetchTopPosts(retryCount + 1);
                }, delay);
            } else {
                $('#loading').find('.spinner').hide();
                $('#loading').html('<p>Failed to load posts. <button onclick="retryFetch()" style="color: #FF4500; background: none; border: none; cursor: pointer; text-decoration: underline;">Try again</button></p>');
                lock = false;
            }
        }

        function retryFetch() {
            $('#loading').html('<div class="spinner"></div>');
            fetchTopPosts(0);
        }

        function createPostCard(postId, postTitle, postSelfText, subreddit, upvotes, imageUrl, galleryImages, isVideo, videoUrl) {
            // Determine if the post has a gallery or video
            const hasGallery = galleryImages.length > 0;
            const hasVideo = isVideo && videoUrl;

            // Create media HTML
            let mediaHtml = '';
            if (hasVideo) {
                mediaHtml = `
                    <div class="card-video">
                        <video controls>
                            <source src="${escapeHtml(videoUrl)}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                `;
            } else if (hasGallery) {
                const slidesHtml = galleryImages.map((img, index) => `<img src="${escapeHtml(img)}" alt="Gallery Image ${index + 1}">`).join('');
                const indicatorsHtml = galleryImages.map((_, index) => `<span data-index="${index}" ${index === 0 ? 'class="active"' : ''}></span>`).join('');

                mediaHtml = `
                    <div class="card-gallery">
                        <div class="gallery-slides">
                            ${slidesHtml}
                        </div>
                        <div class="gallery-nav">
                            <button class="prev" title="Previous Image">&#10094;</button>
                            <button class="next" title="Next Image">&#10095;</button>
                        </div>
                        <div class="gallery-indicators">
                            ${indicatorsHtml}
                        </div>
                    </div>
                `;
            } else if (imageUrl) {
                mediaHtml = `
                    <div class="card-image">
                        <img src="${escapeHtml(imageUrl)}" alt="Post Image">
                    </div>
                `;
            }

            // Create card element with parsed selftext
            const card = $(`
                <div class="card" data-post-id="${postId}">
                    <div class="card-header">
                        <h2>${escapeHtml(postTitle)}</h2>
                        <span class="subreddit">r/${escapeHtml(subreddit)}</span>
                        <span class="upvotes">${upvotes}</span>
                    </div>
                    <div class="card-selftext">${parseSelfText(postSelfText)}</div>
                    ${mediaHtml}
                    <div class="card-content">
                        <p>Loading comments...</p>
                    </div>
                </div>
            `);

            // Append the card to the container
            $('#postsContainer').append(card);

            // Initialize gallery navigation if applicable
            if (hasGallery) {
                initializeGallery(card.find('.card-gallery'));
            }

            // Click event to toggle comments
            card.find('.card-header').on('click', function() {
                const content = $(this).nextAll('.card-content').first();

                if (content.is(':visible')) {
                    content.slideUp();
                } else {
                    // If comments are already loaded, just toggle
                    if (content.data('loaded')) {
                        content.slideDown();
                    } else {
                        // Fetch and display comments
                        fetchComments(postId, content);
                    }
                }
            });
        }

        // Track active gallery for keyboard navigation
        let activeGallery = null;

        function initializeGallery(galleryElement) {
            const slidesContainer = galleryElement.find('.gallery-slides');
            const slides = slidesContainer.find('img');
            const totalSlides = slides.length;
            let currentIndex = 0;

            const prevButton = galleryElement.find('.prev');
            const nextButton = galleryElement.find('.next');
            const indicators = galleryElement.find('.gallery-indicators span');

            // Navigation functions
            function goToPrev() {
                currentIndex = (currentIndex > 0) ? currentIndex - 1 : totalSlides - 1;
                updateGallery();
            }

            function goToNext() {
                currentIndex = (currentIndex < totalSlides - 1) ? currentIndex + 1 : 0;
                updateGallery();
            }

            // Update the slides position
            function updateGallery() {
                slidesContainer.css('transform', `translateX(-${currentIndex * 100}%)`);
                indicators.removeClass('active');
                indicators.eq(currentIndex).addClass('active');
            }

            // Set this gallery as active on click/hover
            galleryElement.on('mouseenter click', function() {
                activeGallery = { goToPrev, goToNext, element: galleryElement };
                $('.card-gallery').removeClass('gallery-focused');
                galleryElement.addClass('gallery-focused');
            });

            // Previous Slide
            prevButton.on('click', function(e) {
                e.stopPropagation();
                goToPrev();
            });

            // Next Slide
            nextButton.on('click', function(e) {
                e.stopPropagation();
                goToNext();
            });

            // Indicator Click
            indicators.on('click', function(e) {
                e.stopPropagation();
                const index = $(this).data('index');
                currentIndex = index;
                updateGallery();
            });

            // Swipe Functionality
            let startX = 0;
            let startY = 0;
            let isSwiping = false;

            slidesContainer.on('touchstart', function(e) {
                if (e.originalEvent.touches.length === 1) { // Only handle single touch
                    startX = e.originalEvent.touches[0].clientX;
                    startY = e.originalEvent.touches[0].clientY;
                    isSwiping = true;
                }
            });

            slidesContainer.on('touchmove', function(e) {
                if (!isSwiping) return;
                const currentX = e.originalEvent.touches[0].clientX;
                const currentY = e.originalEvent.touches[0].clientY;
                const diffX = currentX - startX;
                const diffY = currentY - startY;

                // Determine if the swipe is horizontal
                if (Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
                    if (diffX > 0) {
                        goToPrev();
                    } else {
                        goToNext();
                    }
                    isSwiping = false;
                    e.preventDefault(); // Prevent vertical scrolling
                }
            });

            slidesContainer.on('touchend', function() {
                isSwiping = false;
            });
        }

        // Keyboard navigation for galleries
        $(document).on('keydown', function(e) {
            if (!activeGallery) return;

            // Only handle if not typing in input
            if ($(e.target).is('input, textarea')) return;

            if (e.key === 'ArrowLeft' || e.key === '<' || e.key === ',') {
                e.preventDefault();
                activeGallery.goToPrev();
            } else if (e.key === 'ArrowRight' || e.key === '>' || e.key === '.') {
                e.preventDefault();
                activeGallery.goToNext();
            }
        });

        function fetchComments(postId, contentElement, retryCount = 0) {
            const MAX_RETRIES = 3;
            const RETRY_DELAYS = [1000, 2000, 4000];
            const commentURL = `https://www.reddit.com/r/${SUBREDDIT}/comments/${postId}.json?sort=top&limit=20&raw_json=1`;

            contentElement.html('<p>Loading comments...</p>');

            $.ajax({
                url: commentURL,
                method: 'GET',
                dataType: 'json',
                timeout: 10000,
                success: function(data) {
                    if (!data || !data[1] || !data[1].data) {
                        if (retryCount < MAX_RETRIES) {
                            setTimeout(() => fetchComments(postId, contentElement, retryCount + 1), RETRY_DELAYS[retryCount]);
                            return;
                        }
                        contentElement.html('<p>Failed to load comments.</p>').slideDown();
                        return;
                    }

                    const comments = data[1].data.children
                        .filter(child => child.kind === 't1' && child.data.ups > MIN_UPVOTES)
                        .map(child => child.data)
                        .sort((a, b) => b.ups - a.ups);

                    if (comments.length === 0) {
                        contentElement.html('<p>No comments available.</p>');
                    } else {
                        const commentsHtml = comments.map(comment => `
                            <div class="comment">
                                <div class="comment-body">${parseCommentBody(comment.body)}</div>
                                <div class="comment-upvotes">${comment.ups}</div>
                            </div>
                        `).join('');
                        contentElement.html(commentsHtml);
                    }

                    contentElement.data('loaded', true);
                    contentElement.slideDown();
                },
                error: function(xhr, status, err) {
                    console.error('Error fetching comments:', status, err);
                    if (retryCount < MAX_RETRIES) {
                        contentElement.html(`<p>Retrying... (${retryCount + 2}/${MAX_RETRIES + 1})</p>`);
                        setTimeout(() => fetchComments(postId, contentElement, retryCount + 1), RETRY_DELAYS[retryCount]);
                    } else {
                        contentElement.html('<p>Failed to load comments. <span onclick="$(this).parent().parent().data(\'loaded\', false).find(\'.card-header\').click()" style="color: #FF4500; cursor: pointer; text-decoration: underline;">Try again</span></p>').slideDown();
                    }
                }
            });
        }

        // Utility function to escape HTML to prevent XSS
        function escapeHtml(text) {
            return $('<div>').text(text).html();
        }

        // Function to parse selftext and render images or links where applicable
        // Parse Reddit markdown to HTML
        function parseMarkdown(text) {
            if (!text) return '';

            // Fix encoding issues first
            let parsed = text
                .replace(/&amp;amp;/g, '&')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"');

            // Escape HTML but preserve newlines
            parsed = escapeHtml(parsed);

            // Parse markdown links [text](url) - do this before plain URLs
            parsed = parsed.replace(/\[([^\]]+)\]\(([^)\s]+)\)/g, function(match, linkText, url) {
                // Clean URL of trailing punctuation
                const cleanUrl = url.replace(/[.,;:!?)]+$/, '');
                return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
            });

            // Parse plain URLs (cleaning trailing punctuation)
            parsed = parsed.replace(/(https?:\/\/[^\s<]+)/g, function(url) {
                // Skip if already inside an href or anchor tag
                const before = parsed.substring(0, parsed.indexOf(url));
                if (before.match(/href="[^"]*$/) || before.match(/<a[^>]*>[^<]*$/)) {
                    return url;
                }
                // Remove trailing punctuation that's not part of the URL
                const cleanUrl = url.replace(/[.,;:!?)]+$/, '');
                const trailingPunct = url.slice(cleanUrl.length);

                if (imageRegEx.test(cleanUrl)) {
                    return `<img src="${cleanUrl}" alt="Image" style="max-width:100%; height:auto; display:block; margin:10px 0;">${trailingPunct}`;
                } else {
                    // Truncate display URL if too long
                    const displayUrl = cleanUrl.length > 50 ? cleanUrl.substring(0, 47) + '...' : cleanUrl;
                    return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer">${displayUrl}</a>${trailingPunct}`;
                }
            });

            // Parse Reddit links: /r/subreddit and /u/username
            parsed = parsed.replace(/\/r\/([a-zA-Z0-9_]+)/g, '<a href="https://reddit.com/r/$1" target="_blank">/r/$1</a>');
            parsed = parsed.replace(/\/u\/([a-zA-Z0-9_-]+)/g, '<a href="https://reddit.com/u/$1" target="_blank">/u/$1</a>');

            // Bold: **text** or __text__
            parsed = parsed.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            parsed = parsed.replace(/__([^_]+)__/g, '<strong>$1</strong>');

            // Italic: *text* or _text_
            parsed = parsed.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            parsed = parsed.replace(/\b_([^_]+)_\b/g, '<em>$1</em>');

            // Strikethrough: ~~text~~
            parsed = parsed.replace(/~~([^~]+)~~/g, '<del>$1</del>');

            // Inline code: `code`
            parsed = parsed.replace(/`([^`]+)`/g, '<code style="background:#f0f0f0; padding:2px 5px; border-radius:3px; font-family:monospace;">$1</code>');

            // Superscript: ^text or ^(text)
            parsed = parsed.replace(/\^\(([^)]+)\)/g, '<sup>$1</sup>');
            parsed = parsed.replace(/\^(\S+)/g, '<sup>$1</sup>');

            // Block quotes: > text
            parsed = parsed.replace(/^&gt;\s?(.+)$/gm, '<blockquote style="border-left:3px solid #ccc; padding-left:10px; margin:5px 0; color:#666;">$1</blockquote>');

            // Headers: # ## ###
            parsed = parsed.replace(/^###\s?(.+)$/gm, '<h4 style="margin:10px 0 5px;">$1</h4>');
            parsed = parsed.replace(/^##\s?(.+)$/gm, '<h3 style="margin:10px 0 5px;">$1</h3>');
            parsed = parsed.replace(/^#\s?(.+)$/gm, '<h2 style="margin:10px 0 5px;">$1</h2>');

            // Line breaks: double newline = paragraph, single newline = <br>
            parsed = parsed.replace(/\n\n+/g, '</p><p style="margin:10px 0;">');
            parsed = parsed.replace(/\n/g, '<br>');

            // Wrap in paragraph if content exists
            if (parsed.trim()) {
                parsed = '<p style="margin:0;">' + parsed + '</p>';
            }

            return parsed;
        }

        // Function to parse selftext with markdown
        function parseSelfText(text) {
            return parseMarkdown(text);
        }

        // Function to parse comment body with markdown
        function parseCommentBody(text) {
            return parseMarkdown(text);
        }
    </script>
</body>
</html>
